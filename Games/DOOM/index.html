<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS Raycaster</title>
    <link rel="icon" href="icon.png">
</head>

<body>

<div id="game_div" class="game_div">
    <canvas class="game_canvas" id="game_canvas">
        HTML5 Canvas is not supported. Please update your browser.
    </canvas>
</div>

<div class="erros_div" id="erros_div">
    
</div>

</body>

<script>

const scrWidth = 256;
const scrHeight = 240;
const canvas = document.getElementById("game_canvas");

const roofStyle = "rgb(128,128,128)";
const groundStyle = "rgb(64,64,140)";

canvas.width = scrWidth;
canvas.height = scrHeight;
const ctx = canvas.getContext("2d");
ctx.imageSmoothingEnabled = false;
const images = {
    "Guns":{
        "Pistol":{"Idle":"Assets/Sprites/Guns/Pistol/Idle.png"},
    },
    "Walls":{
    }
};


for(i=1;i<=10;i++){
    let NewImg = new Image();
    NewImg.src = `Assets/Textures/Walls/${i}.png`;
    images["Walls"][i] = NewImg;
}


let NewImg2 = new Image();
NewImg2.src = "Assets/Sprites/Guns/Pistol/Idle.png";
images["Guns"]["Pistol"]["Idle"] = NewImg2;

const map = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,8,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,8,8,8,0,0,0,1,1,0,0,0,0,9,9,0,0,0,1],
    [1,0,0,0,0,8,0,0,0,0,1,1,0,0,0,0,9,9,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,0,1,1,1,1,0,0,0,0,0,8,8,8,8,1],
    [1,0,0,0,0,0,2,0,2,2,1,1,0,0,0,0,0,0,0,0,0,1],
    [2,0,2,0,0,0,2,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1],
    [2,0,2,2,2,2,2,0,2,2,1,1,0,0,0,0,0,0,0,0,0,1],
    [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,9,9,9,0,0,1],
    [2,0,2,0,2,2,2,0,2,2,1,1,0,0,0,0,0,0,0,0,0,1],
    [2,0,2,2,0,0,2,0,2,2,1,1,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,2,2,1,1,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,5,1,1,1,1,1,1,1,1,1,1,1,1,1],
];

const mapWidth = map.length;
const mapHeight = map[0].length;
const renderDistance = 32;

const textureScale = 32;
const wallTextureHeight = 32;
const wallTextureWidth = 32;

let camX = 2;
let camY = 2;
let camAngle = 90;
let fov = 50;
let wallHeight = 5;

let rotateSpeed = 80;
let rotateVel = 0;
let walkSpeed = 3;

let pressedKeys = {};
window.onkeyup = function(e) {pressedKeys[e.code] = false; }
window.onkeydown = function(e) { pressedKeys[e.code] = true; }

function Distance(x1, y1, x2, y2) {
  return Math.hypot(x2 - x1, y2 - y1);
}

function AngleToXYspd(Angle){
    const theta = Angle * Math.PI / 180;
    const vx = Math.cos(theta);
    const vy = Math.sin(theta);
    return [vx,vy];
}

function Ray(percent,startX,startY){
    percent -= .5;
    const stepSize = .05;
    let x = startX;
    let y = startY;
    let angle = camAngle+(fov*percent);
    angle = angle%360;
    const theta = angle * Math.PI / 180;
    const vx = stepSize * Math.cos(theta);
    const vy = stepSize * Math.sin(theta);


    let hitPart = 0;
    let iteration = 0;

    while(hitPart == 0){
        iteration++;
        if(iteration>renderDistance){
            return {
            "Distance":Infinity,
            "Block":0,
            "x":x,
            "y":y,
        };
        }
        if(Math.floor(x)<mapWidth && Math.floor(y)<mapHeight && Math.floor(x)>-1 && Math.floor(y)>-1){
            hitPart = map[Math.floor(x)][Math.floor(y)];
        }else{
            hitPart = 0;
            //return Infinity;
        }
        x+=vx;
        y+=vy;
    }

    return {
        "Distance":Distance(startX,startY,x,y),
        "Block":hitPart,
        "x":x,
        "y":y,
        "side": 0,
    };
}

function SmartRay(percent,startX,startY){
    percent -= .5;
    let x = Math.floor(startX);
    let y = Math.floor(startY);
    
    let angle = camAngle+(fov*percent);
    angle = angle%360;
    const theta = angle * Math.PI / 180;
    let dirX = Math.cos(theta);
    let dirY = Math.sin(theta); 

    const vRayUnitStepSize = {
        "x":Math.sqrt(1 + (dirY/dirX) * (dirY/dirX)),
        "y":Math.sqrt(1 + (dirX/dirY) * (dirX/dirY)) 
    };

    let stepX = 0;
    let stepY = 0;

    let hitPart = 0;
    let iteration = 0;

    let side = 0;

    let lenX = 0;
    let lenY = 0;

    if(dirX<0){
        stepX = -1;
        lenX = (startX-x) * vRayUnitStepSize.x;
    }else{
        stepX = 1;
        lenX = ((x+1)-startX) * vRayUnitStepSize.x;   
    }

    if(dirY<0){
        stepY = -1;
        lenY = (startY-y) * vRayUnitStepSize.y;
    }else{
        stepY = 1;
        lenY = ((y+1)-startY) * vRayUnitStepSize.y;   
    }

    let fDistance = 0;

    while(hitPart == 0 && iteration < renderDistance){
        iteration++;

        if(lenX<lenY){
            x += stepX;
            fDistance = lenX;
            lenX += vRayUnitStepSize.x;
            side = 0;
        }else{
            y += stepY;
            fDistance = lenY;
            lenY += vRayUnitStepSize.y;
            side = 1;
        }

        if(Math.floor(x)<mapWidth && Math.floor(y)<mapHeight && Math.floor(x)>-1 && Math.floor(y)>-1){
            hitPart = map[Math.floor(x)][Math.floor(y)];
        }
    }

    let intersectionX = startX+dirX*fDistance;
    let intersectionY = startY+dirY*fDistance;

    let diff = (angle - camAngle) * Math.PI / 180;
    let correctedDistance = fDistance * Math.cos(diff);

    return {
        "Distance":correctedDistance,
        "Block":hitPart,
        "x":intersectionX,
        "y":intersectionY,
        "side":side,
    };
}


function Clamp(X,Min,Max){
    if(X<Min){
        return Min;
    }else if(X>Max){
        return Max;
    }
    return X;
}

function Render3d(dt){
    ctx.fillStyle = roofStyle;
    ctx.fillRect(0,0,scrWidth,Math.floor(scrHeight/2));
    ctx.fillStyle = groundStyle;
    ctx.fillRect(0,Math.floor(scrHeight/2),scrWidth,scrHeight);
    for(i=0;i<scrWidth;i++){
        let XPercent = i/scrWidth;
        let RAY = SmartRay(XPercent,camX,camY);
        let distance = RAY["Distance"];
        if(distance==Infinity||RAY["Block"]==0){continue;}
        let rayX = RAY["x"];
        let rayY = RAY["y"];

        //ctx.fillStyle = `rgb(${R},${G},${B})`;
        let brightness =  (RAY.side === 1) ? 0.5 : 1.0; 
        let wallHeight = scrHeight/distance;
        let WallImage = images["Walls"][RAY["Block"]];

        rayX *= textureScale; rayY *= textureScale;
        let Y = Math.floor((scrHeight/2)-(wallHeight/2));
        let TexCoordX = Math.floor((rayX+rayY)%wallTextureWidth);
        if(TexCoordX<0){TexCoordX=(-TexCoordX)};

        
        ctx.drawImage(WallImage, TexCoordX, 0, 1, wallTextureHeight, i, Y, 1, Math.floor(wallHeight));
        ctx.fillStyle = `rgba(0,0,0,${1-brightness})`;
        ctx.fillRect(i, Y, 1, Math.floor(wallHeight));

        //ctx.fillRect(i,Math.floor((scrHeight/2)-(wallHeight/2)),1,Math.floor(wallHeight));
    }

    // GUI
    // drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight): Draws a specific portion of the image (defined by source coordinates sx, sy and dimensions sWidth, sHeight) to the canvas at (dx, dy) and scales it to dWidth, dHeight
    let HandImage = images["Guns"]["Pistol"]["Idle"];
    ctx.drawImage(HandImage, 0, 0, scrWidth, scrHeight);
   
}

function Render2d(dt,bg){
    if(bg){
        ctx.fillStyle = "rgb(0,0,0)";
        ctx.fillRect(0,0,scrWidth,scrHeight);
    }
    ctx.fillStyle = "rgb(128,2,2)";

    //let RAY = SmartRay(XPercent,camX,camY);

    let S = 4;

    for(let y=0;y<mapHeight;y++){
        for(let x=0;x<mapWidth;x++){
            let tileType = map[x][y];
            if(tileType != 0){
                ctx.fillRect(x*S,y*S,S,S);
            }
        }
    }
    
    let angle = camAngle%360;
    const theta = angle * Math.PI / 180;
    const dirX = Math.cos(theta)*S;
    const dirY = Math.sin(theta)*S; 

    ctx.fillStyle = `rgb(0,200,255)`;
    ctx.fillRect(camX*S-(S/2),camY*S-(S/2),S,S);

    ctx.fillStyle = `rgb(255,255,0)`;
    ctx.fillRect(camX*S+dirX,camY*S+dirY,1,1);

    for(i=0;i<scrWidth;i++){
        let XPercent = i/scrWidth;
        let RAY = SmartRay(XPercent,camX,camY);

        let rayX = RAY["x"];
        let rayY = RAY["y"];

        ctx.fillStyle = `rgb(255,255,255)`;
        ctx.fillRect(rayX*S,rayY*S,1,1);
    }

}

function FakeSlowHardware(HowSlow){
    // Slow hardware simulator 'o'
    HowSlow *= 100
    let total = 0;
    for (let i = 0; i < HowSlow; i++) {
        let a = Math.sqrt(i);
        a += i;
        total += a; 
    }
    console.log(total);
    console.clear();
}

function Update(dt){
    let oldX = camX;
    let oldY = camY;
    rotateVel = 0;
    let forwardVel = 0;
    let sideVel = 0;
    if(pressedKeys["ArrowLeft"]){
        rotateVel -= rotateSpeed*dt;
    }
    if(pressedKeys["ArrowRight"]){
        rotateVel += rotateSpeed*dt;
    }

    if(pressedKeys["KeyW"] || pressedKeys["ArrowUp"]){
        forwardVel += walkSpeed*dt;
    }
    if(pressedKeys["KeyS"] || pressedKeys["ArrowDown"]){
        forwardVel -= walkSpeed*dt;
    }
    if(pressedKeys["KeyD"]){
        sideVel += walkSpeed*dt;
    }
    if(pressedKeys["KeyA"]){
        sideVel -= walkSpeed*dt;
    }
    
    let speeds = AngleToXYspd(camAngle);
    let velX = speeds[0];
    let velY = speeds[1];
    
    camX += velX*forwardVel;
    camY += velY*forwardVel;
    camX -= velY*sideVel;
    camY += velX*sideVel;
    camAngle += (rotateVel);
    camAngle = camAngle%360;

    if(Math.floor(camX)<mapWidth && Math.floor(oldY)<mapHeight && Math.floor(camX)>-1 && Math.floor(oldY)>-1){
        hitPart = map[Math.floor(camX)][Math.floor(oldY)];
        if(hitPart>0){
            camX = oldX;
        }
    }

    if(Math.floor(oldX)<mapWidth && Math.floor(camY)<mapHeight && Math.floor(oldX)>-1 && Math.floor(camY)>-1){
        hitPart = map[Math.floor(oldX)][Math.floor(camY)];
        if(hitPart>0){
            camY = oldY;
        }
    }
}

let lastTime = performance.now();
function GameLoop() {
    const now = performance.now();
    const deltaTime = (now - lastTime) / 1000; // seconds
    lastTime = now;

    Update(deltaTime);
    Render3d(deltaTime);
   
    setTimeout(GameLoop, 0);
}

GameLoop();

</script>

<style>
    body{
    display: block;
    justify-content: center;
    align-content: center;
    height: 100vh;
    margin: 0px;
    color: aliceblue;
    background-color: #111111;
    background-size: 10px;
    background-repeat: repeat;
    overflow-y: scroll;
    font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
    }

    .erros_div{
        color: red;
    }

    .game_div{
        justify-content: center;
        align-content: center;
        display: grid;
        width: 100%;
        height: 100%;
    }

    .game_canvas{
        position: flex;
        background-color: rgb(255, 0, 255);
        align-self: center;
        width: 1024px;
        height: 900px;
        image-rendering: pixelated;
        user-select: none;
        margin-top: auto;
        margin-bottom: auto;
        
    }
</style>

</html>